 
import numpy as np
import cv2
import math


def get_vert_features(image, dict, feature_width):
  x_k = ['l1x','l2x','l3x','l4x','l5x']
  y_k = ['l1y','l2y','l3y','l4y','l5y']

  cutoff_frequency = 10

  filter1 = cv2.getGaussianKernel(ksize=4,sigma=cutoff_frequency)
  filter1 = np.dot(filter1, filter1.T)

  #Apply the gaussian filter to the image.

  image = cv2.filter2D(image, -1, filter1)
  ImageRows = image.shape[0]
  ImageColumns = image.shape[1]

  vertebrae_amount = 5
  points_per_vert = 4
  dim = 128
  FeatureVectorIn = np.ones((vertebrae_amount, points_per_vert, dim))
  NormalizedFeature = np.zeros((vertebrae_amount, points_per_vert, dim))

  for i in range(len(x_k)):
    x = dict[x_k[i]]
    print(x)
    y = dict[y_k[i]]
    print(y)
    x = np.rint(x)
    x = x.astype(int)
    y = np.rint(y)
    y = y.astype(int)

    for l in range(4):

      #Extract a 16X16 window centered at the corner pixel
      temp1 = int(x[l])
      temp2 = int(y[l])
      Window = image[temp2-8:temp2 + 8, temp1-8:temp1 + 8]
      if(Window.shape != (16,16)):
        continue
    
      # write your own code to extract the feature vectors FeatureVectorIn for this 16 by 16 window. 
      gradient_base_orientations = np.gradient(Window)
      gradient_magnitudes = np.sqrt(gradient_base_orientations[0]**2 + gradient_base_orientations[1]**2)
      gradient_angles = np.rad2deg(np.mod(np.arctan2(gradient_base_orientations[0], gradient_base_orientations[1]), 2*np.pi)).astype('uint32')
      complete_feature_vector = np.zeros((4, 4, 8))
      angle_floor = 360 // 8
      for j in range(Window.shape[0]):
        for k in range(Window.shape[0]):
          vector_y = j // 4
          vector_x = k // 4
          or_index = gradient_angles[j][k] // angle_floor
          if(or_index < 7):
            weight_r = (gradient_angles[j][k] % angle_floor) / angle_floor
            weight_l = (angle_floor - (gradient_angles[j][k] % angle_floor)) / angle_floor
            complete_feature_vector[vector_y, vector_x, or_index] += weight_l * gradient_magnitudes[j][k]
            complete_feature_vector[vector_y,vector_x, or_index+1] += weight_r * gradient_magnitudes[j][k]
          else:
            complete_feature_vector[vector_y,vector_x, or_index] += gradient_magnitudes[j][k]


      FeatureVectorIn[i,l] = complete_feature_vector.flatten()
      print(FeatureVectorIn[i,l])
      #Write your code to normalize the generated feature vector
      NormalizedFeature[i,l] = FeatureVectorIn[i,l]/np.linalg.norm(FeatureVectorIn[i,l],1)
      NormalizedFeature[i,l] = np.clip(FeatureVectorIn[i,l],0,0.2)
      NormalizedFeature[i,l] = NormalizedFeature[i,l]/np.linalg.norm(NormalizedFeature[i,l],1)       
  fv = NormalizedFeature
  return fv




def get_features(image, x, y, feature_width):
    # the goal of this function is to extract a feature vector for each interest point
    
  #Round off the x and y coordinates to integers.

  x = np.rint(x)
  x = x.astype(int)
  y = np.rint(y)
  y = y.astype(int)

  #Define a gaussian filter.

  cutoff_frequency = 10

  filter1 = cv2.getGaussianKernel(ksize=4,sigma=cutoff_frequency)
  filter1 = np.dot(filter1, filter1.T)

  #Apply the gaussian filter to the image.

  image = cv2.filter2D(image, -1, filter1)
  ImageRows = image.shape[0]
  ImageColumns = image.shape[1]

  Xcoordinates = len(x)
  Ycoordinates = len(y)

  dim=384;  # feature dimension
  FeatureVectorIn = np.ones((Xcoordinates,dim)) # each row represents a vector of dim. 
  NormalizedFeature = np.zeros((Xcoordinates,dim))


  #loop over the corners generated by Harris

  for i in range(Xcoordinates):

    #Extract a 16X16 window centered at the corner pixel
    temp1 = int(x[i])
    temp2 = int(y[i])
    Window = image[temp2-8:temp2 + 8, temp1-8:temp1 + 8]
    if(Window.shape != (16,16)):
      continue
    
    # write your own code to extract the feature vectors FeatureVectorIn for this 16 by 16 window. 
    gradient_base_orientations = np.gradient(Window)
    gradient_magnitudes = np.sqrt(gradient_base_orientations[0]**2 + gradient_base_orientations[1]**2)
    gradient_angles = np.rad2deg(np.mod(np.arctan2(gradient_base_orientations[0], gradient_base_orientations[1]), 2*np.pi)).astype('uint32')
    complete_feature_vector = np.zeros((4, 4, 24))
    angle_floor = 360 // 24
    for j in range(Window.shape[0]):
      for k in range(Window.shape[0]):
        vector_y = j // 4
        vector_x = k // 4
        or_index = gradient_angles[j][k] // angle_floor
        if(or_index < 7):
          weight_r = (gradient_angles[j][k] % angle_floor) / angle_floor
          weight_l = (angle_floor - (gradient_angles[j][k] % angle_floor)) / angle_floor
          complete_feature_vector[vector_y, vector_x, or_index] += weight_l * gradient_magnitudes[j][k]
          complete_feature_vector[vector_y,vector_x, or_index+1] += weight_r * gradient_magnitudes[j][k]
        else:
          complete_feature_vector[vector_y,vector_x, or_index] += gradient_magnitudes[j][k]



    FeatureVectorIn[i] = complete_feature_vector.flatten()

    #Write your code to normalize the generated feature vector
    NormalizedFeature[i] = FeatureVectorIn[i]/np.linalg.norm(FeatureVectorIn[i],1)
    NormalizedFeature[i] = np.clip(FeatureVectorIn[i],0,0.2)
    NormalizedFeature[i] = NormalizedFeature[i]/np.linalg.norm(NormalizedFeature[i],1)
 
   
 
  #Return normalized feature vector

  fv = NormalizedFeature
  return fv

